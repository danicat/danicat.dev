---
title: "ハロー、MCPワールド！"
date: 2025-08-17T15:00:00Z
categories: ["AI & Development"]
tags: ["mcp", "gemini", "golang"]
---

> この記事は、2025年8月14日にGophercon UK 2025で行ったキーノートに基づいています。キーノートのスライドについては、こちらの[リンク](https://speakerdeck.com/danicat/hello-mcp-world)をご確認ください。

この記事では、Anthropicによって開発された、Large Language Models（LLM）とアプリケーション間の通信を標準化するためのプロトコルであるModel Context Protocol（MCP）について探求します。

良い習慣として、まずいくつかの定義から始め、次に主要なアーキテクチャコンポーネントを、私自身の学習の過程で実装したサーバーからの実践的な例を交えて説明します。最後に、Gemini CLIを使用したシンプルな「vibe-coded」の例を通して、MCP用のGo SDKを使用して独自のサーバーを作成する方法を見ていきます。

このプロトコルについて初めて聞く方でも、すでに1つか2つサーバーを作成したことがある方でも、この記事がさまざまなレベルの経験を持つ方々に役立つ情報を提供することを目指しています。

## 新しい標準の誕生

標準について話すとき、いつもこのXKCDのコミックが頭に浮かびます。

![標準](image.png)
*出典: [xkcd.com](https://xkcd.com/927)*

面白いことに、業界でこのジョークが完全には当てはまらないのは、これが初めてかもしれません（少なくとも今のところは）。幸いなことに、業界はLLMにコンテキストを追加するための標準として、すぐにMCPに収束しました。

仕様によると、MCPは次のとおりです。

> MCPは、アプリケーションがLarge Language Models（LLM）にコンテキストを提供する方法を標準化するオープンプロトコルです。MCPをAIアプリケーション用のUSB-Cポートのように考えてください。USB-Cがデバイスをさまざまな周辺機器やアクセサリに接続する標準化された方法を提供するように、MCPはAIモデルをさまざまなデータソースやツールに接続する標準化された方法を提供します。MCPを使用すると、LLMの上にエージェントや複雑なワークフローを構築し、モデルを世界と接続できます。

USB-Cとの類推は理解できますが、私はMCPを新しいHTTP/RESTと考える方が好きです。エンジニアとして、私たちは過去約20年間、すべてを「API-first」にすることに費やし、ソフトウェアシステムを相互接続させ、新しいレベルの自動化を実現してきました。次の20年間ではないかもしれませんが、今後5〜10年間で、これらのシステムすべてをAI対応にするために（そして新しいものを作成するために）かなりのエンジニアリングパワーを費やすことになると信じており、MCPはそのプロセスの重要なコンポーネントです。

## MCPアーキテクチャ

この図はMCPアーキテクチャを表しています。

![MCPアーキテクチャ](image-1.png)
*出典: [MCP仕様](https://modelcontextprotocol.io/docs/learn/architecture)*

MCPアーキテクチャの主なコンポーネントは次のとおりです。

*   **MCP Host:** IDEやコーディングエージェントのような主要なAIアプリケーション。ホストはクライアントを使用してMCPサーバーと通信します。
*   **MCP Server:** 何らかの機能へのアクセスを提供するプロセス。
*   **MCP Client:** ホストを単一のサーバーに接続するブリッジ。

## MCPレイヤー

通信は2つのレイヤーで行われます。

* **データレイヤー**: JSON-RPCベースのプロトコルです。メッセージ形式の例は次のセクションで確認できます。
* **トランスポートレイヤー**: 通信チャネルを定義します。主なものは次のとおりです。
  - Standard I/O: ローカルサーバー用
  - Streamable HTTPS: ネットワーク経由の通信用。（HTTPS+SSEを置き換えます）。
  - HTTPS+SSE: セキュリティ上の懸念から、仕様の最新バージョンで非推奨になりました。

## 初期化フロー

JSON-RPC表現を使用した初期化フローは次のようになります。

```json
{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-06-18"}}
{"jsonrpc":"2.0","method":"notifications/initialized","params":{}}
{"jsonrpc":"2.0","id":2,"method":"tools/list","params":{}}
```
「tools/list」や「tools/call」メッセージを直接送信することはできないことに注意してください。そうしないと、「server not ready」タイプのエラーが表示されます。

Gemini CLIのようなコーディングエージェントを介してMCPサーバーをコーディングしている場合、私はよく次のようにシェル経由でこれらのメッセージを送信するように指示します。

```sh
(
  echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-06-18"}}';
  echo '{"jsonrpc":"2.0","method":"notifications/initialized","params":{}}';
  echo '{"jsonrpc":"2.0","id":2,"method":"tools/list","params":{}}';
) | ./bin/godoctor
```

このフローを完全に理解する前は、コーディングエージェントが「サーバーの起動にもっと時間が必要なので、ツールコールの前にスリープを追加します」のような間違った仮定をすることがよくあったため、実装が健全であることを確認するためにこれを行うのが好きです。開発中のMCPサーバーと適切に通信する方法をコーディングエージェントに早く教えるほど、良い結果が得られます！

## MCPサーバーの構成要素

このプロトコルは、3つの基本的な構成要素を定義しており、「プリミティブ」または「サーバーコンセプト」とも呼ばれます。

| 構成要素  | 目的                   | 制御者           | 実世界の例                                     |
| :---------- | :----------------------- | :--------------- | :----------------------------------------------- |
| **Tools**   | AIのアクション用         | モデル制御       | フライト検索、メッセージ送信、コードレビュー     |
| **Resources**| コンテキストデータ用     | アプリケーション制御 | ドキュメント、カレンダー、メール、天気データ     |
| **Prompts** | インタラクションテンプレート用| ユーザー制御     | 「休暇の計画」、「会議の要約」                 |

それぞれを詳しく見ていきましょう。

### Tools

Toolsは、AIモデルがアクションを実行できるようにする関数です。たとえば、API、データベース、またはコマンドラインツールを公開します。

私がツールの概念を実験するために作成したサーバーはGoDoctorと呼ばれ、Goコードを作成するLLMの能力を向上させるためのツールを提供するように設計されています。GoDoctorという名前は、Goパッケージに関するドキュメントを公開するコマンドラインツール「go doc」をもじったものです。

私の仮説は、正しいドキュメントを提供することで、LLMの幻覚が減り、より良いコードを作成できるようになるというものでした。あるいは、少なくとも、間違いを学び、自己修正するためのリソースを持つことができるというものです。

ツールの実装は、MCPサーバーにツールを登録し、ハンドラーを実装するという2つの主要なコンポーネントで構成されます。

登録は`mcp.AddTool`関数を使用して行われます。

{{< github user="danicat" repo="godoctor" path="internal/tools/get_documentation/get_documentation.go" lang="golang" start="35" end="40" >}}

ハンドラーは、既存のコマンドまたは関数を呼び出し、プロトコルと互換性のある方法（`mcp.CallToolResult`構造体）で応答を返すアダプターです。

これはGoDoctorのドキュメントツールのハンドラーです。

{{< github user="danicat" repo="godoctor" path="internal/tools/get_documentation/get_documentation.go" lang="golang" start="49" end="86" >}}

### Prompts

Promptsは、パラメータ化できる再利用可能なユーザー制御のテンプレートを提供します。これらはAIエージェントでスラッシュコマンドとして表示されることが多く、ユーザーは簡単なコマンドで複雑なワークフローを呼び出すことができます。

これを実際に見てみるために、私が作成した別のMCPサーバー`speedgrapher`を見てみましょう。これは、私のテクニカルライティングを支援するためのプロンプトとツールのコレクションです。

`speedgrapher`で最も単純なプロンプトの1つは`/haiku`です。ツールと同様に、プロセスにはプロンプトの定義と、そのハンドラーの実装が含まれます。

{{< github user="danicat" repo="speedgrapher" path="internal/prompts/haiku.go" lang="golang" start="24" end="54" >}}

### Resources

Resourcesは、ファイル、API、またはデータベースからデータを公開し、AIがタスクを実行するために必要なコンテキストを提供します。

正直なところ、ほとんどの人がデータを公開するためにツールをデフォルトで使用するため、リソースが最適である実用的な例をまだ見つけていません。私が使用しているエージェントもまだリソースを実装していないため、適切なユースケースを見つけるまで、この件についてこれ以上深く掘り下げるのは控えます。

ただし、この記事はそれらに言及せずには完全ではありません。

## クライアントコンセプト

接続の反対側では、プロトコルは**クライアントコンセプト**も定義しています。これは、サーバーがクライアントに要求できる機能です。これらには次のものが含まれます。

*   **Sampling:** サーバーがクライアントのモデルからLLM補完を要求できるようにします。サーバーの作成者はモデルを呼び出すために独自のAPIキーを使用する必要がないため、これはセキュリティと請求の観点から有望です。
*   **Roots:** クライアントがファイルシステムの境界を通信するためのメカニズムで、サーバーがどのディレクトリで操作を許可されているかを伝えます。
*   **Elicitation:** サーバーがユーザーから特定の情報を要求するための構造化された方法で、必要に応じて入力を収集するために操作を一時停止します。

前のセクションのリソースと同様に、これらの機能はまだ調査していませんが、次にサンプリングを試すのを楽しみにしています。

## ライブデモ：MCPサーバーのVibeコーディング

これは、「ハローワールド」のようなサーバーを作成するためにお気に入りのコーディングエージェントに与えることができるプロンプトです。最近のエージェントは非決定的であるため、最初の試行で100％機能しない場合があり、最初のプロンプトの後にいくつかの追加のプロンプトでLLMをガイドする必要があるかもしれませんが、良い出発点です。

> あなたのタスクは、「ハローワールド」ツールを公開するModel Context Protocol（MCP）サーバーを作成することです。MCPの実装には、公式のGo SDK for MCPを使用し、stdioトランスポートを使用する必要があります。
>
> コードを作成する前に、これらのリファレンスを読んで、テクノロジーとプロジェクトの構造に関する情報を収集してください。
> - https://raw.githubusercontent.com/modelcontextprotocol/go-sdk/refs/heads/main/README.md
> - https://go.dev/doc/modules/layout
>
> サーバーをテストするには、次のようなシェルコマンドを使用します。
> `( echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2025-06-18"}}' ; echo '{"jsonrpc":"2.0","method":"notifications/initialized","params":{}}'; echo '{"jsonrpc":"2.0","id":2,"method":"tools/list","params":{}}'; ) | ./bin/hello`

エージェントがこのタスクを正常に完了した場合、新しいツールに対して「method tools/call」を実行して結果を確認するように依頼してください！

## 未来を覗く

GoコミュニティはMCPエコシステムに積極的に投資しています。注目すべき2つの主要なプロジェクトは次のとおりです。

*   **The Go SDK for MCP:** デモで使用した公式SDKで、GoogleとAnthropicのパートナーシップです。[github.com/modelcontextprotocol/go-sdk](https://github.com/modelcontextprotocol/go-sdk)で入手できます。
*   **`gopls`のMCPサポート:** Go言語サーバーである`gopls`はMCPサポートを追加しており、Go開発エクスペリエンスにさらに深いAI統合をもたらします。[tip.golang.org/gopls/features/mcp](https://tip.golang.org/gopls/features/mcp)で進捗状況を追跡できます。

## 便利なMCPサーバー

MCPサーバーのエコシステムは成長しています。私が構築したもの以外にも、ワークフローを強化するために使用できる他の多くのサーバーが利用可能です。注目すべき例をいくつか紹介します。

*   **Playwright:** Microsoftによって維持されており、このサーバーを使用すると、AIエージェントがWebページをナビゲートしたり、スクリーンショットを撮ったり、ブラウザータスクを自動化したりできます。[https://github.com/microsoft/playwright-mcp](https://github.com/microsoft/playwright-mcp)で入手できます。
*   **Context7:** このサーバーは、クラウドソーシングされたリポジトリからドキュメントを取得し、エージェントに別の豊富なコンテキストソースを提供します。[https://context7.com/](https://context7.com/)で詳細をご覧ください。

## 自分で作ってみませんか？

Model Context Protocolは、AIエージェントの機能を拡張するための標準化された方法を提供します。独自のサーバーを構築することで、特定のワークフローに合わせて、特殊でコンテキストを認識するアシスタントを作成できます。

始めたい場合は、独自のMCPサーバーをゼロから構築するプロセスを案内するGoogle Codelabを作成しました。

[**Gemini CLI、MCP、Goでコーディングアシスタントを構築する方法**](https://codelabs.developers.google.com/codelabs/gemini-cli-mcp-go)

## 最後に

この記事を楽しんでいただけたでしょうか。ご質問やご意見がございましたら、下のコメント欄または私のソーシャルのいずれかでお気軽にご連絡ください。ありがとうございました！
